{"version":3,"file":"index.js","mappings":"AAeA,MAAMA,GACY,EAQlB,SAASC,EAASC,KAAoBC,GAChCH,GACFI,QAAQC,IAAI,gBAAgBH,OAAcC,EAE9C,CAuDA,SAASG,EAAyBC,GAChC,IAEE,MAAMC,EAAUC,IAAIC,WAAW,CAAEC,KAAM,SAIjCC,EAAkB,0DAExB,IAAIC,EAAgB,EAEpB,MAAMC,EAAeP,EAAKQ,QAAQH,EAAiB,CAACI,EAAOC,KACzD,IAEE,MAAMC,EAhCd,SAAmBD,GACjB,IAAIC,EAAOD,EAAQE,OAOnB,OAJKD,EAAKE,WAAW,MAAQF,EAAKG,SAAS,MAAUH,EAAKE,WAAW,OAAQF,EAAKG,SAAS,SACzFH,EAAOA,EAAKI,MAAM,GAAI,IAGjBJ,CACT,CAuBqBK,CAAUN,GACvBhB,EAAS,4BAA4BiB,MAGrC,MAAMM,EAjEd,SAAyBhB,EAAsBU,GAC7C,IACE,OAAOO,EAAEC,IAAIlB,EAAQmB,UAAWT,EAClC,CAAE,MAAOU,GAEP,YADA3B,EAAS,iCAAiCiB,IAAQU,EAEpD,CACF,CA0D6BC,CAAgBrB,EAASU,GAG9C,YAAqBY,IAAjBN,GACFvB,EAAS,6CAA6CiB,KAC/CF,GAtDXe,OAFiBA,EA4DGP,KArDjBQ,MAAMC,QAAQF,IAA2B,iBAAVA,GAiEhC9B,EAAS,qCAAqCiB,cAAiBM,MACxDR,IAZLf,EAAS,qDAAqDiB,KAAS,CACrEM,aAAcA,EACdU,UAAWF,MAAMC,QAAQT,GAAgB,QAAU,SACnDW,QAASnB,EAAMG,SAGjBN,IACO,GAMX,CAAE,MAAOe,GAGP,OADA3B,EAAS,4CAA4Ce,EAAMG,SAAUS,GAC9DZ,CACT,CA9EN,IAAuBe,IAsFnB,OAJIlB,EAAgB,GAClBuB,OAAOC,KAAK,OAAOxB,0BAGdC,CACT,CAAE,MAAOc,GAGP,OADA3B,EAAS,kEAAmE2B,GACrErB,CACT,CACF,CAiEA+B,EAAE,KACArC,EAAS,sDAGTsC,sBAAsB,OACnBC,KAAK,KACJvC,EAAS,gDA/DbA,EAAS,wDAGTwC,eAAeC,cAAcC,iBAAkBC,MAAOC,IACpD,IACE5C,EAAS,wBAAwB4C,KAGjC,MAAMC,EAAWC,gBAAgBF,GACjC,IAAKC,GAAgC,IAApBA,EAASE,OAExB,YADA/C,EAAS,WAAW4C,gCAItB,MACMI,EADUH,EAAS,GACO5C,QAGhC,IAAK+C,GAA8C,KAA3BA,EAAgB9B,OAEtC,YADAlB,EAAS,WAAW4C,2CAKtB,MAAMK,EAAkB5C,EAAyB2C,GAG7CC,IAAoBD,GACtBhD,EAAS,WAAW4C,yCAEdM,gBACJ,CACE,CACEN,WAAYA,EACZ3C,QAASgD,IAGb,CAAEE,QAAS,SAGbnD,EAAS,WAAW4C,uBAEpB5C,EAAS,WAAW4C,uBAExB,CAAE,MAAOjB,GACP3B,EAAS,4BAA4B4C,KAAejB,EACtD,IAGF3B,EAAS,4CAoBLA,EAAS,8DAEVoD,MAAMzB,IACL3B,EAAS,wCAAyC2B,OASxDU,EAAEgB,QAAQC,GAAG,WAAY,KACvBtD,EAAS","sources":["src://tavern_helper_template/src/var_update_restrict/index.ts"],"sourcesContent":["/**\n * MVU Variable Update Restriction Script\n *\n * Function: Intercept and delete _.set() commands that update complex variables (arrays, objects)\n * Keep _.set() commands that update simple variables (numbers, strings, booleans)\n * Does not affect _.insert, _.delete and other MVU commands\n */\n\n// Configuration\n\ninterface FilterConfig {\n  /** Enable debug logging */\n  enableDebugLog: boolean;\n}\n\nconst config: FilterConfig = {\n  enableDebugLog: true,\n};\n\n// Utility Functions\n\n/**\n * Debug logging output\n */\nfunction debugLog(message: string, ...args: any[]): void {\n  if (config.enableDebugLog) {\n    console.log(`[MVU Filter] ${message}`, ...args);\n  }\n}\n\n/**\n * Safely get variable value\n * @param mvuData MVU data object\n * @param path Variable path\n * @returns Variable value, or undefined if failed\n */\nfunction safeGetVariable(mvuData: Mvu.MvuData, path: string): any {\n  try {\n    return _.get(mvuData.stat_data, path);\n  } catch (error) {\n    debugLog(`Failed to get variable value: ${path}`, error);\n    return undefined;\n  }\n}\n\n/**\n * Check if value is complex type (object or array)\n * @param value Value to check\n * @returns true if complex type, false otherwise\n */\nfunction isComplexType(value: any): boolean {\n  // Check for null first (typeof null === 'object')\n  if (value === null || value === undefined) {\n    return false;\n  }\n\n  // Check for array or object\n  return Array.isArray(value) || typeof value === 'object';\n}\n\n/**\n * Clean path argument, remove quotes and whitespace\n * @param pathArg Raw path argument\n * @returns Cleaned path string\n */\nfunction cleanPath(pathArg: string): string {\n  let path = pathArg.trim();\n\n  // Remove surrounding quotes (single or double)\n  if ((path.startsWith('\"') && path.endsWith('\"')) || (path.startsWith(\"'\") && path.endsWith(\"'\"))) {\n    path = path.slice(1, -1);\n  }\n\n  return path;\n}\n\n// Core Filter Function\n\n/**\n * Filter _.set() commands that try to update complex variables\n * @param text Original text\n * @returns Filtered text\n */\nfunction filterComplexSetCommands(text: string): string {\n  try {\n    // Get current MVU data at chat level\n    const mvuData = Mvu.getMvuData({ type: 'chat' });\n\n    // Regex: Match _.set(..., ...);//... format\n    // Support optional semicolon and comment parts\n    const setCommandRegex = /_\\.set\\s*\\(\\s*([^,]+)\\s*,\\s*[^)]+\\)\\s*;?\\s*(?:\\/\\/.*)?/g;\n\n    let filteredCount = 0;\n\n    const filteredText = text.replace(setCommandRegex, (match, pathArg) => {\n      try {\n        // Clean and extract variable path\n        const path = cleanPath(pathArg);\n        debugLog(`Checking variable path: \"${path}\"`);\n\n        // Get current variable value\n        const currentValue = safeGetVariable(mvuData, path);\n\n        // If variable doesn't exist, conservative approach: keep command\n        if (currentValue === undefined) {\n          debugLog(`Variable does not exist, keeping command: ${path}`);\n          return match;\n        }\n\n        // Check if current value is complex type\n        if (isComplexType(currentValue)) {\n          debugLog(`Found complex variable update command, removing: \"${path}\"`, {\n            currentValue: currentValue,\n            valueType: Array.isArray(currentValue) ? 'array' : 'object',\n            command: match.trim(),\n          });\n\n          filteredCount++;\n          return ''; // Delete entire command\n        }\n\n        // Simple type variable, keep command\n        debugLog(`Simple variable update, keeping: \"${path}\" (${typeof currentValue})`);\n        return match;\n      } catch (error) {\n        // Error parsing single command, conservative approach: keep command\n        debugLog(`Error parsing command, keeping original: ${match.trim()}`, error);\n        return match;\n      }\n    });\n\n    // Show notification if any commands were filtered\n    if (filteredCount > 0) {\n      toastr.info(`已删除 ${filteredCount} 个不合规的 _.set 复杂变量更新命令`);\n    }\n\n    return filteredText;\n  } catch (error) {\n    // Overall filtering error, return original text\n    debugLog('Serious error during filtering process, returning original text', error);\n    return text;\n  }\n}\n\n// Event Listeners\n\n/**\n * Initialize event listeners\n */\nfunction initializeEventListeners(): void {\n  debugLog('Initializing message interception event listeners...');\n\n  // Listen to message received event, execute before all other listeners\n  eventMakeFirst(tavern_events.MESSAGE_RECEIVED, async (message_id: number) => {\n    try {\n      debugLog(`Intercepted message: ${message_id}`);\n\n      // Get message content\n      const messages = getChatMessages(message_id);\n      if (!messages || messages.length === 0) {\n        debugLog(`Message ${message_id} does not exist or is empty`);\n        return;\n      }\n\n      const message = messages[0];\n      const originalContent = message.message;\n\n      // If message content is empty, return directly\n      if (!originalContent || originalContent.trim() === '') {\n        debugLog(`Message ${message_id} content is empty, skipping processing`);\n        return;\n      }\n\n      // Execute filtering\n      const filteredContent = filterComplexSetCommands(originalContent);\n\n      // If content has changed, update message\n      if (filteredContent !== originalContent) {\n        debugLog(`Message ${message_id} content filtered, updating...`);\n\n        await setChatMessages(\n          [\n            {\n              message_id: message_id,\n              message: filteredContent,\n            },\n          ],\n          { refresh: 'none' },\n        );\n\n        debugLog(`Message ${message_id} update completed`);\n      } else {\n        debugLog(`Message ${message_id} needs no filtering`);\n      }\n    } catch (error) {\n      debugLog(`Error processing message ${message_id}:`, error);\n    }\n  });\n\n  debugLog('Event listeners initialization completed');\n}\n\n// Main Entry Point\n\n/**\n * Script main entry point\n */\n$(() => {\n  debugLog('MVU variable update restriction script starting...');\n\n  // Wait for MVU framework initialization\n  waitGlobalInitialized('Mvu')\n    .then(() => {\n      debugLog('MVU framework initialized, setting up filter');\n\n      // Initialize event listeners\n      initializeEventListeners();\n\n      // Show startup success message\n      debugLog('MVU variable update restriction script startup completed');\n    })\n    .catch(error => {\n      debugLog('Error waiting for MVU initialization:', error);\n    });\n});\n\n// ==================== Cleanup on Unload ====================\n\n/**\n * Cleanup work when page unloads\n */\n$(window).on('pagehide', () => {\n  debugLog('MVU variable update restriction script unloaded');\n});\n"],"names":["config","debugLog","message","args","console","log","filterComplexSetCommands","text","mvuData","Mvu","getMvuData","type","setCommandRegex","filteredCount","filteredText","replace","match","pathArg","path","trim","startsWith","endsWith","slice","cleanPath","currentValue","_","get","stat_data","error","safeGetVariable","undefined","value","Array","isArray","valueType","command","toastr","info","$","waitGlobalInitialized","then","eventMakeFirst","tavern_events","MESSAGE_RECEIVED","async","message_id","messages","getChatMessages","length","originalContent","filteredContent","setChatMessages","refresh","catch","window","on"],"sourceRoot":""}