{"version":3,"file":"index.js","mappings":"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","sources":["src://tavern_helper_template/src/var_change/config/constants.ts","src://tavern_helper_template/src/var_change/utils/array-utils.ts","src://tavern_helper_template/src/var_change/config/characters.ts","src://tavern_helper_template/src/var_change/utils/character-utils.ts","src://tavern_helper_template/src/var_change/handlers/character-handler.ts","src://tavern_helper_template/src/var_change/handlers/plot-handler.ts","src://tavern_helper_template/src/var_change/config/change-limits.ts","src://tavern_helper_template/src/var_change/utils/number-utils.ts","src://tavern_helper_template/src/var_change/config/value-constraints.ts","src://tavern_helper_template/src/var_change/handlers/validation-handler.ts","src://tavern_helper_template/src/var_change/handlers/worldbook-handler.ts","src://tavern_helper_template/src/var_change/index.ts","src://tavern_helper_template/src/var_change/handlers/special-handler.ts","src://tavern_helper_template/src/var_change/handlers/array-deduplication-handler.ts"],"sourcesContent":["import type { InternalKeys } from '../types/constants';\n\n/**\n * 内部常量定义\n */\nexport const INTERNAL_KEYS: InternalKeys = {\n  /** 次要角色状态存储键名（存储在stat_data中以确保持久性） */\n  PREVIOUS_SECONDARY_CHARACTERS_KEY: '_internal.previousSecondaryCharacters',\n} as const;\n","/**\n * 去除数组中的重复文本\n * @param array - 需要去重的数组\n * @returns 去重后的数组\n */\nexport function removeDuplicateTexts(array: any[]): any[] {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n\n  const seen = new Set<string>();\n  const filtered: any[] = [];\n\n  for (const item of array) {\n    // 对于文本类型，进行去重\n    if (typeof item === 'string') {\n      const trimmedItem = item.trim();\n      if (trimmedItem && !seen.has(trimmedItem)) {\n        seen.add(trimmedItem);\n        filtered.push(item);\n      }\n    } else {\n      // 对于非字符串类型，直接添加（保持原有逻辑）\n      filtered.push(item);\n    }\n  }\n\n  return filtered;\n}\n","import type { AllowedSecondaryCharacters } from '../types/constants';\n\n/**\n * 允许的次要角色列表\n */\nexport const ALLOWED_SECONDARY_CHARACTERS: AllowedSecondaryCharacters = [\n  '莉瑟尔·冯·阿尔卡德 (血族公主)',\n  '艾露薇娅·瑟兰迪尔 (精灵公主)',\n  '理子 (机械生命，前文明独立作战单元)',\n  '露克希娅 (天使，高阶司书)',\n  '青璇 (龙裔，青龙，古老盟约的孤独守护者)',\n  '橘奈绪 (百兽裔，猫又亚种，斥候与猎手)',\n  '琥珀 (百兽裔，九尾狐亚种，情报贩子)',\n];\n","import { ALLOWED_SECONDARY_CHARACTERS } from '../config/characters';\nimport type { CurrentTimeAndLocation } from '../types/index';\n\n/**\n * 获取角色的标准化名字（用于记录key，避免重复）\n * @param characterName - 角色名称\n * @returns 标准化的名字\n */\nexport function getStandardizedRecordName(characterName: string): string {\n  const normalizedInput = characterName.trim();\n  // 返回输入的第一个名字\n  const fallbackName = normalizedInput.split(' (')[0].trim();\n  return fallbackName.split('·')[0].trim();\n}\n\n/**\n * 检查次要角色是否在允许列表中\n * @param characterName - 角色名称\n * @returns 是否允许该角色\n */\nexport function isAllowedSecondaryCharacter(characterName: string): boolean {\n  // 支持多种匹配方式\n  const normalizedInput = characterName.trim();\n\n  // 1. 完全匹配\n  if (ALLOWED_SECONDARY_CHARACTERS.includes(normalizedInput)) {\n    return true;\n  }\n\n  // 2. 去除括号后匹配（匹配主名称）\n  for (const allowedChar of ALLOWED_SECONDARY_CHARACTERS) {\n    const mainName = allowedChar.split(' (')[0].trim();\n    const inputMainName = normalizedInput.split(' (')[0].trim();\n    if (mainName === inputMainName) {\n      return true;\n    }\n  }\n\n  // 3. 检查名字匹配（如'莉瑟尔'、'艾露薇娅'）\n  for (const allowedChar of ALLOWED_SECONDARY_CHARACTERS) {\n    const mainName = allowedChar.split(' (')[0].trim();\n\n    // 提取第一个名字（通常是·分隔的第一部分）\n    const firstName = mainName.split('·')[0].trim();\n\n    // 检查输入是否匹配第一个名字\n    if (firstName === normalizedInput) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * 获取当前全局信息中的时间和地点\n * @param stat_data - stat_data对象\n * @returns 包含时间和地点的对象\n */\nexport function getCurrentTimeAndLocation(stat_data: Record<string, any>): CurrentTimeAndLocation {\n  const globalInfo = _.get(stat_data, '全局信息', {});\n  return {\n    时间: _.get(globalInfo, '时间', ''),\n    地点: _.get(globalInfo, '当前位置', ''),\n    日期: _.get(globalInfo, '日期', ''),\n  };\n}\n","import type { CharacterRecord } from '../types/index';\nimport {\n  getCurrentTimeAndLocation,\n  getStandardizedRecordName,\n  isAllowedSecondaryCharacter,\n} from '../utils/character-utils';\n\n/**\n * 检查并清理不允许的次要角色\n * @param stat_data - stat_data对象\n */\nexport function validateSecondaryCharacters(stat_data: Record<string, any>): void {\n  if (!_.has(stat_data, '次要角色')) {\n    return;\n  }\n\n  const secondaryCharacters = _.get(stat_data, '次要角色');\n  if (!_.isObject(secondaryCharacters) || Array.isArray(secondaryCharacters)) {\n    return;\n  }\n\n  const charactersToRemove: string[] = [];\n\n  // 检查所有次要角色\n  for (const characterName in secondaryCharacters) {\n    if (!isAllowedSecondaryCharacter(characterName)) {\n      charactersToRemove.push(characterName);\n    }\n  }\n\n  // 移除不允许的角色\n  if (charactersToRemove.length > 0) {\n    console.log(`[次要角色限制] 检测到不允许的角色，正在移除: ${charactersToRemove.join(', ')}`);\n    for (const characterName of charactersToRemove) {\n      _.unset(stat_data, `次要角色.${characterName}`);\n    }\n  }\n}\n\n/**\n * 处理次要角色出场\n * @param stat_data - stat_data对象\n * @param characterName - 角色名称\n */\nexport function handleSecondaryCharacterEntry(stat_data: Record<string, any>, characterName: string): void {\n  if (!_.has(stat_data, '次要角色记录')) {\n    _.set(stat_data, '次要角色记录', {});\n  }\n\n  const currentInfo = getCurrentTimeAndLocation(stat_data);\n\n  // 使用标准化的名字作为记录key，避免同一人物多次记录\n  const standardizedName = getStandardizedRecordName(characterName);\n  const recordPath = `次要角色记录.${standardizedName}`;\n  const characterPath = `次要角色.${characterName}`;\n\n  // 检查是否已有记录\n  const characterRecord = _.get(stat_data, recordPath);\n  const isReturning = characterRecord && typeof characterRecord === 'object';\n\n  if (isReturning) {\n    // 角色重新出场 - 恢复信任值\n    console.log(`[次要角色管理] ${characterName} (记录名: ${standardizedName}) 重新出场，恢复记录信息`);\n\n    // 恢复信任值\n    const savedTrustValue = _.get(characterRecord, '信任值', 0.01);\n    if (_.has(stat_data, `${characterPath}.信任值`)) {\n      _.set(stat_data, `${characterPath}.信任值`, savedTrustValue);\n      console.log(`[次要角色管理] 恢复 ${characterName} 的信任值: ${savedTrustValue}`);\n    }\n\n    // 恢复物品（合并，新物品优先）\n    const savedItems = _.get(characterRecord, '离场时持有的物品', {});\n    const currentItems = _.get(stat_data, `${characterPath}.持有物品`, {});\n\n    if (Object.keys(savedItems).length > 0) {\n      // 合并物品：当前物品优先，然后添加之前的物品\n      const mergedItems = { ...savedItems, ...currentItems };\n\n      _.set(stat_data, `${characterPath}.持有物品`, mergedItems);\n      console.log(`[次要角色管理] 恢复 ${characterName} 的物品，合并${Object.keys(savedItems).length}件之前的物品`);\n    }\n\n    // 更新出场信息\n    _.set(stat_data, `${recordPath}.出场次数`, _.get(characterRecord, '出场次数', 0) + 1);\n    _.set(stat_data, `${recordPath}.出场地点`, currentInfo.地点);\n    _.set(stat_data, `${recordPath}.出场时间`, `${currentInfo.日期} ${currentInfo.时间}`);\n    _.set(stat_data, `${recordPath}.离场地点`, '待定');\n    _.set(stat_data, `${recordPath}.离场时间`, 'N/A');\n  } else {\n    // 首次出场 - 创建新记录\n    console.log(`[次要角色管理] ${characterName} (记录名: ${standardizedName}) 首次出场，创建新记录`);\n\n    const newRecord: CharacterRecord = {\n      出场次数: 1,\n      出场地点: currentInfo.地点,\n      出场时间: `${currentInfo.日期} ${currentInfo.时间}`,\n      离场地点: '待定',\n      离场时间: 'N/A',\n      信任值: _.get(stat_data, `${characterPath}.信任值`, 0.01),\n      离场时持有的物品: {},\n    };\n\n    _.set(stat_data, recordPath, newRecord);\n  }\n\n  console.log(`[次要角色管理] ${characterName} 出场记录已更新`);\n}\n\n/**\n * 处理次要角色离场\n * @param stat_data - stat_data对象\n * @param characterName - 角色名称\n * @param characterData - 角色数据（离场前的数据）\n */\nexport function handleSecondaryCharacterExit(\n  stat_data: Record<string, any>,\n  characterName: string,\n  characterData: Record<string, any>,\n): void {\n  if (!_.has(stat_data, '次要角色记录')) {\n    _.set(stat_data, '次要角色记录', {});\n  }\n\n  const currentInfo = getCurrentTimeAndLocation(stat_data);\n\n  // 使用标准化的名字作为记录key\n  const standardizedName = getStandardizedRecordName(characterName);\n  const recordPath = `次要角色记录.${standardizedName}`;\n\n  console.log(`[次要角色管理] ${characterName} (记录名: ${standardizedName}) 离场，保存当前状态`);\n\n  // 确保有基础记录\n  if (!_.has(stat_data, recordPath)) {\n    const defaultRecord: CharacterRecord = {\n      出场次数: 1,\n      出场地点: '',\n      出场时间: '',\n      离场地点: '待定',\n      离场时间: 'N/A',\n      信任值: 0.01,\n      离场时持有的物品: {},\n    };\n    _.set(stat_data, recordPath, defaultRecord);\n  }\n\n  // 保存离场信息\n  _.set(stat_data, `${recordPath}.离场地点`, currentInfo.地点);\n  _.set(stat_data, `${recordPath}.离场时间`, `${currentInfo.日期} ${currentInfo.时间}`);\n\n  // 保存当前信任值\n  const currentTrust = _.get(characterData, '信任值', 0.01);\n  _.set(stat_data, `${recordPath}.信任值`, currentTrust);\n\n  // 保存当前持有物品\n  const currentItems = _.get(characterData, '持有物品', {});\n  _.set(stat_data, `${recordPath}.离场时持有的物品`, currentItems);\n\n  console.log(\n    `[次要角色管理] ${characterName} 离场状态已保存 - 信任值: ${currentTrust}, 物品数量: ${Object.keys(currentItems).length}`,\n  );\n}\n\n/**\n * 检测次要角色的变化（添加/删除）\n * @param stat_data - stat_data对象\n * @param oldSecondaryCharacters - 旧的次要角色对象\n * @param newSecondaryCharacters - 新的次要角色对象\n */\nexport function detectSecondaryCharacterChanges(\n  stat_data: Record<string, any>,\n  oldSecondaryCharacters: Record<string, any>,\n  newSecondaryCharacters: Record<string, any>,\n): void {\n  if (!oldSecondaryCharacters || !newSecondaryCharacters) {\n    return;\n  }\n\n  const oldCharNames = Object.keys(oldSecondaryCharacters);\n  const newCharNames = Object.keys(newSecondaryCharacters);\n\n  // 检测新增角色（出场）\n  const addedCharacters = newCharNames.filter(name => !oldCharNames.includes(name));\n  for (const characterName of addedCharacters) {\n    handleSecondaryCharacterEntry(stat_data, characterName);\n  }\n\n  // 检测删除角色（离场）\n  const removedCharacters = oldCharNames.filter(name => !newCharNames.includes(name));\n  for (const characterName of removedCharacters) {\n    const characterData = oldSecondaryCharacters[characterName];\n    handleSecondaryCharacterExit(stat_data, characterName, characterData);\n  }\n}\n\n/**\n * 处理次要角色相关的变更\n * @param stat_data - stat_data对象\n * @param path - 变量路径\n * @param newValue - 新值\n */\nexport function handleCharacterUpdate(stat_data: Record<string, any>, path: string, newValue: any): void {\n  if (path === '次要角色') {\n    // 在次要角色对象被更新后，检查并清理不允许的角色\n    validateSecondaryCharacters(stat_data);\n  }\n}\n","import { removeDuplicateTexts } from '../utils/array-utils';\n\n/**\n * 处理剧情节点记录去重\n * @param stat_data - stat_data对象\n */\nexport function deduplicatePlotNodeRecords(stat_data: Record<string, any>): void {\n  if (!_.has(stat_data, 'plot_record.剧情节点记录')) {\n    return;\n  }\n\n  const plotNodeRecords = _.get(stat_data, 'plot_record.剧情节点记录');\n  if (Array.isArray(plotNodeRecords)) {\n    const originalLength = plotNodeRecords.length;\n    const deduplicated = removeDuplicateTexts(plotNodeRecords);\n\n    if (deduplicated.length !== originalLength) {\n      _.set(stat_data, 'plot_record.剧情节点记录', deduplicated);\n      console.log(\n        `[剧情节点去重] 已去除 ${originalLength - deduplicated.length} 个重复记录，当前记录数: ${deduplicated.length}`,\n      );\n    }\n  }\n}\n\n/**\n * 处理剧情进度变更\n * @param stat_data - stat_data对象\n * @param path - 变量路径\n * @param oldValue - 旧值\n * @param newValue - 新值\n */\nexport function handlePlotProgress(stat_data: Record<string, any>, path: string, oldValue: any, newValue: any): void {\n  if (path === 'plot_record.剧情进度') {\n    console.log(`剧情进度从 \"${oldValue}\" 变更为 \"${newValue}\"`);\n\n    // 清空剧情节点记录\n    if (_.has(stat_data, 'plot_record.剧情节点记录')) {\n      _.set(stat_data, 'plot_record.剧情节点记录', []);\n      console.log('已清空剧情节点记录');\n    }\n  }\n\n  // 当剧情节点记录被更新时，进行去重处理\n  if (path === 'plot_record.剧情节点记录') {\n    deduplicatePlotNodeRecords(stat_data);\n  }\n}\n","import type { ChangeLimitsConfig } from '../types/index';\n\n/**\n * 数值变化限制配置\n */\nexport const CHANGE_LIMITS: ChangeLimitsConfig = {\n  // 主要角色变化限制\n  '主要角色.白.关注度': {\n    minChange: -0.014,\n    maxChange: 0.026,\n  },\n  '主要角色.澪.好感度': {\n    minChange: -0.05,\n    maxChange: 0.08,\n  },\n  '主要角色.澪.治愈进度': {\n    minChange: -5,\n    maxChange: Number.POSITIVE_INFINITY, // 正向变化不限制\n  },\n\n  // 模式匹配变化限制\n  pattern_信任值: { minChange: -0.15, maxChange: 0.2 },\n  pattern_好感度: { minChange: -0.05, maxChange: 0.08 },\n  pattern_依赖度: { minChange: -0.05, maxChange: 0.08 },\n  pattern_认可度: { minChange: -0.05, maxChange: 0.08 },\n  pattern_污秽侵蚀度: {\n    minChange: -0.05,\n    maxChange: 0.1,\n  },\n  pattern_模因侵蚀率: {\n    minChange: -0.3,\n    maxChange: 0.05,\n  },\n};\n","import type { NumberConstraintFunction } from '../types/index';\n\n/**\n * 格式化浮点数，精确到小数点后5位并去除尾随零\n * @param value - 需要格式化的浮点数\n * @returns 格式化后的数值\n */\nexport function formatFloat(value: number): number {\n  // 保留5位小数，然后转换为数字以去除尾随零\n  return parseFloat(value.toFixed(5));\n}\n\n/**\n * 创建原生数值约束函数\n * @param min - 最小值\n * @param max - 最大值\n * @param isInteger - 是否为整数，默认false\n * @returns 约束函数\n */\nexport function createNumberConstraint(min: number, max: number, isInteger = false): NumberConstraintFunction {\n  return (value: any): number => {\n    // 强制转换为数字\n    let numValue = Number(value);\n\n    // 如果转换失败，返回最小值\n    if (isNaN(numValue)) {\n      console.warn(`[数值变化限制] 无法将值转换为数字：${value}`);\n      numValue = min;\n    }\n\n    // 范围限制\n    let clampedVal = Math.max(min, Math.min(max, numValue));\n\n    // 如果是整数，确保结果也是整数\n    if (isInteger) {\n      clampedVal = Math.round(clampedVal);\n    } else {\n      clampedVal = formatFloat(clampedVal);\n    }\n\n    return clampedVal;\n  };\n}\n","import type { ValueConstraintsConfig } from '../types/index';\nimport { createNumberConstraint } from '../utils/number-utils';\n\n/**\n * 数值验证约束函数\n */\nexport const VALUE_CONSTRAINTS: ValueConstraintsConfig = {\n  // 主要角色数值限制\n  '主要角色.白.关注度': createNumberConstraint(0, 1),\n  '主要角色.澪.好感度': createNumberConstraint(-1, 1),\n  '主要角色.澪.治愈进度': createNumberConstraint(0, 90, true),\n\n  // 模式匹配约束\n  pattern_信任值: createNumberConstraint(-1, 1),\n  pattern_好感度: createNumberConstraint(-1, 1),\n  pattern_依赖度: createNumberConstraint(-1, 1),\n  pattern_认可度: createNumberConstraint(-1, 1),\n  pattern_污秽侵蚀度: createNumberConstraint(0, 1),\n  pattern_模因侵蚀率: createNumberConstraint(0, 1),\n};\n","import { CHANGE_LIMITS } from '../config/change-limits';\nimport { VALUE_CONSTRAINTS } from '../config/value-constraints';\nimport type { ChangeLimitConfig, NumberConstraintFunction } from '../types/index';\n\n/**\n * 获取变化限制配置\n * @param path - 变量路径\n * @returns 对应的变化限制配置\n */\nexport function getChangeLimitForPath(path: string): ChangeLimitConfig | null {\n  // 直接匹配\n  if (CHANGE_LIMITS[path]) {\n    return CHANGE_LIMITS[path];\n  }\n\n  // 模式匹配\n  if (path.includes('次要角色') && path.endsWith('.信任值')) {\n    return CHANGE_LIMITS.pattern_信任值;\n  }\n\n  if (path.includes('特殊角色')) {\n    if (path.endsWith('.好感度')) {\n      return CHANGE_LIMITS.pattern_好感度;\n    } else if (path.endsWith('.依赖度')) {\n      return CHANGE_LIMITS.pattern_依赖度;\n    } else if (path.endsWith('.认可度')) {\n      return CHANGE_LIMITS.pattern_认可度;\n    } else if (path.endsWith('.污秽侵蚀度')) {\n      return CHANGE_LIMITS.pattern_污秽侵蚀度;\n    } else if (path.endsWith('.模因侵蚀率')) {\n      return CHANGE_LIMITS.pattern_模因侵蚀率;\n    }\n  }\n\n  return null;\n}\n\n/**\n * 获取对应的约束函数\n * @param path - 变量路径\n * @returns 对应的约束函数\n */\nexport function getConstraintForPath(path: string): NumberConstraintFunction | null {\n  // 直接匹配\n  if (VALUE_CONSTRAINTS[path]) {\n    return VALUE_CONSTRAINTS[path];\n  }\n\n  // 模式匹配\n  if (path.includes('次要角色') && path.endsWith('.信任值')) {\n    return VALUE_CONSTRAINTS.pattern_信任值;\n  }\n\n  if (path.includes('特殊角色')) {\n    if (path.endsWith('.好感度')) {\n      return VALUE_CONSTRAINTS.pattern_好感度;\n    } else if (path.endsWith('.依赖度')) {\n      return VALUE_CONSTRAINTS.pattern_依赖度;\n    } else if (path.endsWith('.认可度')) {\n      return VALUE_CONSTRAINTS.pattern_认可度;\n    } else if (path.endsWith('.污秽侵蚀度')) {\n      return VALUE_CONSTRAINTS.pattern_污秽侵蚀度;\n    } else if (path.endsWith('.模因侵蚀率')) {\n      return VALUE_CONSTRAINTS.pattern_模因侵蚀率;\n    }\n  }\n\n  return null;\n}\n\n/**\n * 应用变化幅度限制\n * @param newValue - 新值\n * @param oldValue - 旧值\n * @param changeLimit - 变化限制配置\n * @param path - 变量路径（用于日志）\n * @returns 限制后的值\n */\nexport function applyChangeLimit(\n  newValue: number,\n  oldValue: number,\n  changeLimit: ChangeLimitConfig,\n  path: string,\n): number {\n  const actualChange = newValue - oldValue;\n\n  // 特殊处理：正向无限制变化（澪的治愈进度）\n  if (changeLimit.maxChange === Number.POSITIVE_INFINITY) {\n    if (actualChange < 0 && actualChange < changeLimit.minChange) {\n      const limitedValue = oldValue + changeLimit.minChange;\n      console.log(`变化幅度限制: ${path} 负向变化 ${actualChange.toFixed(5)} 限制为 ${changeLimit.minChange}`);\n      return limitedValue;\n    }\n    return newValue; // 正向变化无限制\n  }\n\n  // 标准双向变化限制\n  if (actualChange > changeLimit.maxChange) {\n    const limitedValue = oldValue + changeLimit.maxChange;\n    console.log(`变化幅度限制: ${path} 正向变化 ${actualChange.toFixed(5)} 限制为 ${changeLimit.maxChange}`);\n    return limitedValue;\n  }\n\n  if (actualChange < changeLimit.minChange) {\n    const limitedValue = oldValue + changeLimit.minChange;\n    console.log(`变化幅度限制: ${path} 负向变化 ${actualChange.toFixed(5)} 限制为 ${changeLimit.minChange}`);\n    return limitedValue;\n  }\n\n  return newValue; // 在允许范围内\n}\n\n/**\n * 验证和修复数值\n * @param value - 要验证的值\n * @param path - 变量路径\n * @param oldValue - 旧值\n * @returns 修复后的值\n */\nexport function validateAndFixValue(value: any, path: string, oldValue: any = null): any {\n  const constraint = getConstraintForPath(path);\n  const changeLimit = getChangeLimitForPath(path);\n\n  if (!constraint) {\n    return value;\n  }\n\n  try {\n    // 基本的类型转换和范围限制\n    let result = constraint(value);\n\n    // 应用变化幅度限制\n    if (changeLimit && oldValue !== null && typeof oldValue === 'number') {\n      result = applyChangeLimit(result, oldValue, changeLimit, path);\n\n      // 确保限制后的值仍在约束范围内\n      result = constraint(result);\n    }\n\n    // 记录修复日志（如果值有变化）\n    if (result !== value) {\n      const fixType = typeof value !== 'number' ? '类型转换' : '范围限制';\n      console.log(`数值修复: ${path} 从 ${value} ${fixType}为 ${result}`);\n    }\n\n    return result;\n  } catch (error) {\n    console.error(`数值验证失败: ${path} = ${value}`, error instanceof Error ? error.message : String(error));\n    return value; // 验证失败时保留原值\n  }\n}\n","// 注入提示词的ID，用于管理和移除\nconst WORLDBOOK_SCAN_PROMPT_ID = 'var-change-worldbook-scan';\n\n/**\n * 处理世界书扫描文本设置\n * @param stat_data - stat_data对象\n */\nexport function updateWorldbookScanText(stat_data: Record<string, any>): void {\n  const scanTexts: string[] = [];\n\n  // 添加当前位置作为扫描文本\n  const currentLocation = _.get(stat_data, '全局信息.当前位置', '');\n  if (currentLocation && typeof currentLocation === 'string') {\n    scanTexts.push(currentLocation.trim());\n  }\n\n  // 添加所有次要角色名称作为扫描文本\n  const secondaryCharacters = _.get(stat_data, '次要角色', {});\n  if (_.isObject(secondaryCharacters) && !Array.isArray(secondaryCharacters)) {\n    for (const characterName of Object.keys(secondaryCharacters)) {\n      if (characterName && typeof characterName === 'string') {\n        // 添加角色名\n        scanTexts.push(characterName.trim());\n      }\n    }\n  }\n\n  // 去重并过滤空文本\n  const uniqueScanTexts = [...new Set(scanTexts)].filter(text => text.length > 0);\n\n  if (uniqueScanTexts.length > 0) {\n    // 先移除之前的注入提示词\n    uninjectPrompts([WORLDBOOK_SCAN_PROMPT_ID]);\n\n    // 创建扫描文本内容\n    const scanTextString = uniqueScanTexts.join(', ');\n\n    // 使用 injectPrompts 注入世界书扫描文本\n    try {\n      injectPrompts([\n        {\n          id: WORLDBOOK_SCAN_PROMPT_ID,\n          position: 'none', // 不发给AI，只用来激活世界书\n          depth: 0,\n          role: 'user',\n          content: scanTextString,\n          should_scan: true, // 作为欲扫描文本，加入世界书扫描\n        },\n      ]);\n\n      console.log(`[世界书扫描] 注入扫描文本: ${scanTextString}`);\n    } catch (error) {\n      console.warn(`[世界书扫描] 注入扫描文本失败:`, error instanceof Error ? error.message : String(error));\n    }\n  } else {\n    // 如果没有扫描文本，移除之前的注入\n    uninjectPrompts([WORLDBOOK_SCAN_PROMPT_ID]);\n  }\n}\n","import { INTERNAL_KEYS } from './config/constants';\nimport { deduplicateAllArrayVariables } from './handlers/array-deduplication-handler';\nimport {\n  detectSecondaryCharacterChanges,\n  handleCharacterUpdate,\n  validateSecondaryCharacters,\n} from './handlers/character-handler';\nimport { deduplicatePlotNodeRecords, handlePlotProgress } from './handlers/plot-handler';\nimport { handleMioStabilizer } from './handlers/special-handler';\nimport { validateAndFixValue } from './handlers/validation-handler';\nimport { updateWorldbookScanText } from './handlers/worldbook-handler';\nimport type { PendingValidation } from './types';\n\n// 存储需要延迟验证的变量更新\nconst PENDING_VALIDATIONS: PendingValidation[] = [];\n\n/**\n * 处理MVU变量更新开始事件\n * @param variables - 包含stat_data的变量记录\n * @param out_is_updated - 指示是否已有更新的标志\n */\nfunction variableUpdateStarted(variables: Record<string, any>): void {\n  console.log('Variable update started');\n\n  // 在变量更新开始时检查并清理不允许的次要角色\n  if (variables?.stat_data) {\n    validateSecondaryCharacters(variables.stat_data);\n\n    // 存储当前次要角色状态用于后续比较（存储在stat_data中确保持久性）\n    const currentSecondaryCharacters = _.get(variables.stat_data, '次要角色');\n    _.set(\n      variables.stat_data,\n      INTERNAL_KEYS.PREVIOUS_SECONDARY_CHARACTERS_KEY,\n      _.cloneDeep(currentSecondaryCharacters),\n    );\n  }\n}\n\n/**\n * 处理MVU变量更新事件\n * @param stat_data - 包含更新变量的数据结构\n * @param path - 标识被更新变量的路径或键\n * @param oldValue - 变量更新前的值\n * @param newValue - 变量更新后的值\n */\nfunction variableUpdated(stat_data: Record<string, any>, path: string, oldValue: any, newValue: any): void {\n  console.log(`Variable updated: ${path} from ${oldValue} to ${newValue}`);\n\n  // 记录需要验证的更新\n  PENDING_VALIDATIONS.push({\n    stat_data,\n    path,\n    oldValue,\n    newValue,\n  });\n\n  // 调用各个专门的处理函数（使用原始新值）\n  handleCharacterUpdate(stat_data, path, newValue);\n  handlePlotProgress(stat_data, path, oldValue, newValue);\n  handleMioStabilizer(stat_data, path, newValue);\n}\n\n/**\n * 处理MVU变量更新结束事件\n * @param variables - 包含状态和显示相关数据的对象\n * @param out_is_updated - 指示变量在处理过程中是否被更新的标志\n */\nfunction variableUpdateEnded(variables: Record<string, any>): void {\n  console.log('Variable update ended');\n\n  // 现在执行延迟的数值验证\n  if (PENDING_VALIDATIONS.length > 0) {\n    console.log(`[延迟验证] 处理 ${PENDING_VALIDATIONS.length} 个待验证的变量更新`);\n\n    for (const validation of PENDING_VALIDATIONS) {\n      const { stat_data, path, oldValue, newValue } = validation;\n\n      // 获取当前实际值\n      const currentValue = _.get(stat_data, path);\n\n      // 对当前值进行验证和修复\n      const validatedValue = validateAndFixValue(currentValue, path, oldValue);\n\n      if (validatedValue !== currentValue) {\n        _.set(stat_data, path, validatedValue);\n        console.log(`[延迟验证] 数值已修复: ${path} = ${validatedValue}`);\n      }\n    }\n\n    // 清空待验证列表\n    PENDING_VALIDATIONS.length = 0;\n  }\n\n  if (variables?.stat_data) {\n    // 在变量更新结束时再次验证次要角色（确保最终一致性）\n    validateSecondaryCharacters(variables.stat_data);\n\n    // 剧情节点记录去重\n    deduplicatePlotNodeRecords(variables.stat_data);\n\n    // 对所有数组变量进行去重\n    deduplicateAllArrayVariables(variables.stat_data);\n\n    // 检测次要角色变化\n    const currentSecondaryCharacters = _.get(variables.stat_data, '次要角色');\n    const previousSecondaryCharacters = _.get(variables.stat_data, INTERNAL_KEYS.PREVIOUS_SECONDARY_CHARACTERS_KEY);\n\n    if (previousSecondaryCharacters && currentSecondaryCharacters) {\n      detectSecondaryCharacterChanges(variables.stat_data, previousSecondaryCharacters, currentSecondaryCharacters);\n    }\n\n    // 更新存储的状态（存储在stat_data中确保持久性）\n    _.set(\n      variables.stat_data,\n      INTERNAL_KEYS.PREVIOUS_SECONDARY_CHARACTERS_KEY,\n      _.cloneDeep(currentSecondaryCharacters),\n    );\n\n    // 更新世界书扫描文本\n    updateWorldbookScanText(variables.stat_data);\n  }\n}\n\n// 注册MVU事件监听器\n$(() => {\n  eventOn('mag_variable_update_started', variableUpdateStarted);\n  eventOn('mag_variable_updated', variableUpdated);\n  eventOn('mag_variable_update_ended', variableUpdateEnded);\n\n  console.log('MVU变量处理脚本已加载');\n});\n","/**\n * 处理澪的星尘稳定剂注入相关逻辑\n * @param stat_data - stat_data对象\n * @param path - 变量路径\n * @param newValue - 新值\n */\nexport function handleMioStabilizer(stat_data: Record<string, any>, path: string, newValue: any): void {\n  // 检查澪是否注入星尘稳定剂\n  if (path === '主要角色.澪.注入星尘稳定剂' && newValue === 1) {\n    console.log(`澪.注入星尘稳定剂 的值变为 1，设置治愈进度为 90`);\n\n    // 将治愈进度设置为 90（这是直接设置，不受变化幅度限制）\n    if (_.has(stat_data, '主要角色.澪.治愈进度')) {\n      _.set(stat_data, '主要角色.澪.治愈进度', 90);\n      console.log('澪的治愈进度已设置为 90');\n    }\n  }\n\n  // 防止治愈进度在已注入星尘稳定剂的情况下被修改\n  if (path === '主要角色.澪.治愈进度' && _.get(stat_data, '主要角色.澪.注入星尘稳定剂') === 1) {\n    console.log(`澪已注入星尘稳定剂，治愈进度不得修改，恢复为 90`);\n    _.set(stat_data, '主要角色.澪.治愈进度', 90);\n  }\n}\n","import { removeDuplicateTexts } from '../utils/array-utils';\n\n/**\n * 对所有数组类型的变量进行去重处理\n * @param stat_data - stat_data对象\n */\nexport function deduplicateAllArrayVariables(stat_data: Record<string, any>): void {\n  const arrayPaths: string[] = [];\n\n  // 收集主要角色的数组变量路径\n  const mainCharacters = ['<user>', '白', '澪'];\n  for (const char of mainCharacters) {\n    if (_.has(stat_data, `主要角色.${char}`)) {\n      arrayPaths.push(`主要角色.${char}.身份`);\n      // 白没有当前状态，其他主要角色有\n      if (char !== '白') {\n        arrayPaths.push(`主要角色.${char}.当前状态`);\n      }\n    }\n  }\n\n  // 收集特殊角色的数组变量路径\n  const specialCharacters = ['Lily', '布施翠', '蛭子小比奈'];\n  for (const char of specialCharacters) {\n    if (_.has(stat_data, `特殊角色.${char}`)) {\n      arrayPaths.push(`特殊角色.${char}.身份`);\n      arrayPaths.push(`特殊角色.${char}.当前状态`);\n    }\n  }\n\n  // 对所有数组变量进行去重\n  let totalDeduplicated = 0;\n  for (const path of arrayPaths) {\n    const arrayValue = _.get(stat_data, path);\n    if (Array.isArray(arrayValue) && arrayValue.length > 0) {\n      const originalLength = arrayValue.length;\n      const deduplicated = removeDuplicateTexts(arrayValue);\n\n      if (deduplicated.length !== originalLength) {\n        _.set(stat_data, path, deduplicated);\n        totalDeduplicated += originalLength - deduplicated.length;\n        console.log(`[数组去重] ${path}: 去除 ${originalLength - deduplicated.length} 个重复项`);\n      }\n    }\n  }\n\n  if (totalDeduplicated > 0) {\n    console.log(`[数组去重] 总共去除 ${totalDeduplicated} 个重复项`);\n  }\n}\n"],"names":["INTERNAL_KEYS","removeDuplicateTexts","array","Array","isArray","seen","Set","filtered","item","trimmedItem","trim","has","add","push","ALLOWED_SECONDARY_CHARACTERS","getStandardizedRecordName","characterName","split","isAllowedSecondaryCharacter","normalizedInput","includes","allowedChar","getCurrentTimeAndLocation","stat_data","globalInfo","_","get","validateSecondaryCharacters","secondaryCharacters","isObject","charactersToRemove","length","console","log","join","unset","handleSecondaryCharacterEntry","set","currentInfo","standardizedName","recordPath","characterPath","characterRecord","savedTrustValue","savedItems","currentItems","Object","keys","mergedItems","newRecord","handleSecondaryCharacterExit","characterData","defaultRecord","currentTrust","deduplicatePlotNodeRecords","plotNodeRecords","originalLength","deduplicated","CHANGE_LIMITS","minChange","maxChange","Number","POSITIVE_INFINITY","createNumberConstraint","min","max","isInteger","value","numValue","isNaN","warn","clampedVal","Math","round","parseFloat","toFixed","formatFloat","VALUE_CONSTRAINTS","validateAndFixValue","path","oldValue","constraint","endsWith","getConstraintForPath","changeLimit","getChangeLimitForPath","result","newValue","actualChange","limitedValue","applyChangeLimit","fixType","error","Error","message","String","WORLDBOOK_SCAN_PROMPT_ID","PENDING_VALIDATIONS","variableUpdateStarted","variables","currentSecondaryCharacters","cloneDeep","variableUpdated","handleCharacterUpdate","handlePlotProgress","handleMioStabilizer","variableUpdateEnded","validation","currentValue","validatedValue","arrayPaths","mainCharacters","char","specialCharacters","totalDeduplicated","arrayValue","deduplicateAllArrayVariables","previousSecondaryCharacters","oldSecondaryCharacters","newSecondaryCharacters","oldCharNames","newCharNames","addedCharacters","filter","name","removedCharacters","detectSecondaryCharacterChanges","scanTexts","currentLocation","uniqueScanTexts","text","uninjectPrompts","scanTextString","injectPrompts","id","position","depth","role","content","should_scan","updateWorldbookScanText","$","eventOn"],"sourceRoot":""}